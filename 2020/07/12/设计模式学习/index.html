<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="设计模式的学习, 归来仍是少年">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>设计模式的学习 | 归来仍是少年</title>
    <link rel="icon" type="image/png" href="/medias/logo01.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo02.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">归来仍是少年</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo02.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">归来仍是少年</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">设计模式的学习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%9F%BA%E7%A1%80/">
                                <span class="chip bg-color">基础</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-07-12
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[TOC]</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><strong>设计模式</strong>是软件设计中常见问题的典型解决方案。</p>
<span id="more"></span>

<p>所有模式可以根据其意图或目的来分类：</p>
<ul>
<li><strong>创建型模式</strong>提供创建对象的机制， 增加已有代码的灵活性和可复用性。</li>
<li><strong>结构型模式</strong>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</li>
<li><strong>行为模式</strong>负责对象间的高效沟通和职责委派。</li>
</ul>
<p>对象上来分，这种方式可分为：</p>
<ul>
<li><strong>类模式</strong>:用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。</li>
<li><strong>对象模式</strong>:用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类模式</strong></td>
<td>工厂方法</td>
<td>(类）适配器</td>
<td>模板方法、解释器</td>
</tr>
<tr>
<td><strong>对象模式</strong></td>
<td>单例 原型 抽象工厂 建造者</td>
<td>代理 (对象）适配器 桥接 装饰 外观 享元 组合</td>
<td>策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录</td>
</tr>
</tbody></table>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>​		<strong>开闭原则</strong>是总纲，它告诉我们要对扩展开放，对修改关闭；<strong>里氏替换原则</strong>告诉我们不要破坏继承体系；<strong>依赖倒置原则</strong>告诉我们要面向接口编程；<strong>单一职责原则</strong>告诉我们实现类要职责单一；<strong>接口隔离原则</strong>告诉我们在设计接口的时候要精简单一；<strong>迪米特法则</strong>告诉我们要降低耦合度；<strong>合成复用原则</strong>告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</p>
<ul>
<li><strong>单一职责</strong>:这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。</li>
<li><h3 id="开闭原则-软件实体（项目中划分出的模块-x2F-类与接口-x2F-方法）应当对扩展开放，对修改关闭。软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。"><a href="#开闭原则-软件实体（项目中划分出的模块-x2F-类与接口-x2F-方法）应当对扩展开放，对修改关闭。软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。" class="headerlink" title="开闭原则:软件实体（项目中划分出的模块&#x2F;类与接口&#x2F;方法）应当对扩展开放，对修改关闭。软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。"></a><strong>开闭原则</strong>:软件实体（项目中划分出的模块&#x2F;类与接口&#x2F;方法）应当对扩展开放，对修改关闭。软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</h3></li>
<li><strong>里氏替换</strong>:继承必须确保超类所拥有的性质在子类中仍然成立。子类可以扩展父类的功能，但不能改变父类原有的功能。它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</li>
<li><strong>依赖倒转</strong>:高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</li>
<li><strong>接口隔离</strong>:要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</li>
<li><h3 id="合成复用-通常类的复用分为继承复用和合成复用两种，合成复用要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。"><a href="#合成复用-通常类的复用分为继承复用和合成复用两种，合成复用要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。" class="headerlink" title="合成复用:通常类的复用分为继承复用和合成复用两种，合成复用要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。"></a><strong>合成复用</strong>:通常类的复用分为继承复用和合成复用两种，合成复用要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</h3></li>
<li><h3 id="迪米特法则-如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。"><a href="#迪米特法则-如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。" class="headerlink" title="迪米特法则:如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。"></a><strong>迪米特法则</strong>:如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</h3></li>
</ul>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>这类模式提供创建对象的机制， 能够提升已有代码的灵活性和可复用性。</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>亦称：虚拟构造函数、Virtual Constructor、Factory Method</p>
<p><strong>工厂方法模式</strong>是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>可以<strong>避免</strong>创建者和具体产品之间的<strong>紧密耦合</strong>。</li>
<li><em><strong>单一职责原则</strong></em>。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li>
<li><em><strong>开闭原则</strong></em>。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li>在许多设计工作的初期都会使用<strong>工厂方法模式</strong>（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用<strong>抽象工厂模式</strong>、 <strong>原型模式</strong>或<strong>生成器模式</strong>（更灵活但更加复杂）。</li>
<li><strong>抽象工厂模式</strong>通常基于一组<strong>工厂方法</strong>， 但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</li>
<li>你可以同时使用<strong>工厂方法</strong>和<strong>迭代器模式</strong>来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</li>
<li><strong>原型</strong>并不基于继承， 因此没有继承的缺点。 另一方面， <em>原型</em>需要对被复制对象进行复杂的初始化。 <strong>工厂方法</strong>基于继承， 但是它不需要初始化步骤。</li>
<li><strong>工厂方法</strong>是<strong>模板方法模式</strong>的一种特殊形式。 同时， <strong>工厂方法</strong>可以作为一个大型<strong>模板方法</strong>中的一个步骤。</li>
</ul>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><strong>亦称：</strong> Abstract Factory</p>
<p><strong>抽象工厂模式</strong>是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以确保同一工厂生成的产品相互匹配。</li>
<li>你可以避免客户端和具体产品代码的耦合。</li>
<li><em>单一职责原则</em>。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。</li>
<li><em>开闭原则</em>。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>生成器</strong>重点关注如何分步生成复杂对象。<strong>抽象工厂</strong>专门用于生产一系列相关对象。 <strong>抽象工厂</strong>会马上返回产品， <strong>生成器</strong>则允许你在获取产品前执行一些额外构造步骤。</li>
<li><strong>抽象工厂模式</strong>通常基于一组工厂方法， 但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用<strong>抽象工厂</strong>来代替<strong>外观模式</strong>。</li>
<li>你可以将<strong>抽象工厂</strong>和<strong>桥接模式</strong>搭配使用。 如果由<strong>桥接</strong>定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， <strong>抽象工厂</strong>可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li>
</ul>
<h3 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h3><p><strong>亦称：</strong> 建造者模式、 Builder</p>
<p><strong>生成器模式</strong>是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。</li>
<li>生成不同形式的产品时， 你可以复用相同的制造代码。</li>
<li><em>单一职责原则</em>。 你可以将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>生成器</strong>重点关注如何分步生成复杂对象。<strong>抽象工厂</strong>专门用于生产一系列相关对象。 <strong>抽象工厂</strong>会马上返回产品， <strong>生成器</strong>则允许你在获取产品前执行一些额外构造步骤。</li>
<li>你可以在创建复杂组合模式树时使用<strong>生成器</strong>， 因为这可使其构造步骤以递归的方式运行。</li>
<li>你可以结合使用<strong>生成器</strong>和<strong>桥接模式</strong>： <strong>主管类</strong>负责抽象工作， 各种不同的<strong>生成器</strong>负责实现工作。</li>
</ul>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><strong>亦称：</strong> 克隆、 Clone、 Prototype</p>
<p><strong>原型模式</strong>是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以克隆对象， 而无需与它们所属的具体类相耦合。</li>
<li>你可以克隆预生成原型， 避免反复运行初始化代码。</li>
<li>你可以更方便地生成复杂对象。</li>
<li>你可以用继承以外的方式来处理复杂对象的不同配置。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>克隆包含循环引用的复杂对象可能会非常麻烦。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>抽象工厂模式</strong>通常基于一组工厂方法， 但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</li>
<li><strong>原型</strong>可用于保存<strong>命令模式</strong>的历史记录。</li>
<li>大量使用<strong>组合模式</strong>和<strong>装饰模式</strong>的设计通常可从对于<strong>原型</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</li>
<li><strong>原型</strong>并不基于继承， 因此没有继承的缺点。 另一方面， <strong>原型</strong>需要对被复制对象进行复杂的初始化。 <strong>工厂方法</strong>基于继承， 但是它不需要初始化步骤。</li>
<li>有时候原型可以作为<strong>备忘录模式</strong>的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>亦称：</strong> 单件模式、 Singleton</p>
<p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以保证一个类只有一个实例。</li>
<li>你获得了一个指向该实例的全局访问节点。</li>
<li>仅在首次请求单例对象时对其进行初始化。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>违反了_单一职责原则_。 该模式同时解决了两个问题。</li>
<li>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</li>
<li>该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。</li>
<li>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>外观模式类</strong>通常可以转换为<strong>单例模式类</strong>， 因为在大部分情况下一个外观对象就足够了。</li>
<li>如果你能将对象的所有共享状态简化为一个享元对象， 那么<strong>享元模式</strong>就和<strong>单例</strong>类似了。 但这两个模式有两个根本性的不同。<ol>
<li>只会有一个单例实体， 但是<strong>享元</strong>类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li><strong>单例</strong>对象可以是可变的。 享元对象是不可变的。</li>
</ol>
</li>
<li><strong>抽象工厂</strong>、 <strong>生成器</strong>和<strong>原型</strong>都可以用单例模式来实现。</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>这类模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>亦称：</strong> 封装器模式、 Wrapper、 Adapter</p>
<p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>单一职责原则。你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li>
<li><em>开闭原则</em>。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>桥接模式</strong>通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， <strong>适配器模式</strong>通常在已有程序中使用， 让相互不兼容的类能很好地合作。</li>
<li><strong>适配器</strong>可以对已有对象的接口进行修改，<strong>装饰模式</strong>则能在不改变对象接口的前提下强化对象功能。 此外， <strong>装饰</strong>还支持递归组合， <strong>适配器</strong>则无法实现。</li>
<li><strong>适配器</strong>能为被封装对象提供不同的接口， <strong>代理模式</strong>能为对象提供相同的接口， <strong>装饰</strong>则能为对象提供加强的接口。</li>
<li><strong>外观模式</strong>为现有对象定义了一个新接口， <strong>适配器</strong>则会试图运用已有的接口。 <em>适配器</em>通常只封装一个对象， <em>外观</em>通常会作用于整个对象子系统上。</li>
<li><strong>桥接</strong>、<strong>状态模式</strong>和<strong>策略模式</strong>（在某种程度上包括<strong>适配器</strong>） 模式的接口非常相似。 实际上， 它们都基于<strong>组合模式</strong>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
</ul>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><strong>亦称</strong>： Bridge</p>
<p><strong>桥接模式</strong>是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以创建与平台无关的类和程序。</li>
<li>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</li>
<li><em>开闭原则</em>。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li>
<li><em>单一职责原则</em>。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>桥接</strong>、 <strong>状态模式</strong>和<strong>策略模式</strong>（在某种程度上包括<strong>适配器</strong>） 模式的接口非常相似。 实际上， 它们都基于<strong>组合模式</strong>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li>你可以将<strong>抽象工厂模式</strong>和<strong>桥接</strong>搭配使用。 如果由<strong>桥接</strong>定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， <strong>抽象工厂</strong>可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li>
<li>你可以结合使用<strong>生成器模式</strong>和<strong>桥接模式</strong>： <strong>主管</strong>类负责抽象工作， 各种不同的<strong>生成器</strong>负责<strong>实现</strong>工作。</li>
</ul>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>亦称： 对象树、 Object Tree、 Composite</p>
<p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以利用多态和递归机制更方便地使用复杂树结构。</li>
<li><em>开闭原则</em>。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p><strong>桥接模式</strong>、 <strong>状态模式</strong>和<strong>策略模式</strong>（在某种程度上包括<strong>适配器模式</strong>） 模式的接口非常相似。 实际上， 它们都基于<strong>组合模式</strong>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li><p>你可以在创建复杂<strong>组合</strong>树时使用<strong>生成器模式</strong>， 因为这可使其构造步骤以递归的方式运行。</p>
</li>
<li><p><strong>责任链模式</strong>通常和<strong>组合模式</strong>结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li><p>你可以使用<strong>迭代器模式</strong>来遍历<strong>组合</strong>树。</p>
</li>
<li><p>你可以使用<strong>访问者模式</strong>对整个<strong>组合</strong>树执行操作。</p>
</li>
<li><p>你可以使用<strong>享元模式</strong>实现<strong>组合</strong>树的共享叶节点以节省内存。</p>
</li>
<li><p><strong>组合</strong>和<strong>装饰模式</strong>的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p><strong>装饰</strong>类似于<strong>组合</strong>， 但其只有一个子组件。 此外还有一个明显不同： <strong>装饰</strong>为被封装对象添加了额外的职责， <strong>组合</strong>仅对其子节点的结果进行了 “求和”。</p>
<p>但是， 模式也可以相互合作： 你可以使用<strong>装饰</strong>来扩展<strong>组合</strong>树中特定对象的行为。</p>
</li>
<li><p>大量使用<strong>组合</strong>和<strong>装饰</strong>的设计通常可从对于<strong>原型模式</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
</ul>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p><strong>亦称</strong>： 装饰者模式、 装饰器模式、 Wrapper、 Decorator</p>
<p><strong>装饰模式</strong>是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你无需创建新子类即可扩展对象的行为。</li>
<li>你可以在运行时添加或删除对象的功能。</li>
<li>你可以用多个装饰封装对象来组合几种行为。</li>
<li><em>单一职责原则</em>。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>在封装器栈中删除特定封装器比较困难。</li>
<li>实现行为不受装饰栈顺序影响的装饰比较困难。</li>
<li>各层的初始化配置代码看上去可能会很糟糕。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p><strong>适配器模式</strong>可以对已有对象的接口进行修改， <strong>装饰模式</strong>则能在不改变对象接口的前提下强化对象功能。 此外， <strong>装饰</strong>还支持递归组合， <strong>适配器</strong>则无法实现。</p>
</li>
<li><p><strong>适配器</strong>能为被封装对象提供不同的接口， <strong>代理模式</strong>能为对象提供相同的接口， <strong>装饰</strong>则能为对象提供加强的接口。</p>
</li>
<li><p><strong>责任链模式</strong>和<strong>装饰模式</strong>的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p>
</li>
<li><p><strong>责任链</strong>的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， <strong>装饰</strong>无法中断请求的传递。</p>
</li>
<li><p><strong>组合模式</strong>和<strong>装饰</strong>的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
</li>
<li><p><strong>装饰</strong>类似于<strong>组合</strong>， 但其只有一个子组件。 此外还有一个明显不同： <strong>装饰</strong>为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。但是， 模式也可以相互合作： 你可以使用<strong>装饰</strong>来扩展<strong>组合树</strong>中特定对象的行为。</p>
</li>
<li><p>大量使用<strong>组合</strong>和<strong>装饰</strong>的设计通常可从对于<strong>原型模式</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
<li><p><strong>装饰</strong>可让你更改对象的外表， <strong>策略模式</strong>则让你能够改变其本质。</p>
</li>
<li><p><strong>装饰</strong>和<strong>代理</strong>有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于<strong>代理</strong>通常自行管理其服务对象的生命周期， 而<strong>装饰</strong>的生成则总是由客户端进行控制。</p>
</li>
</ul>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong>亦称</strong>： 门面模式、 Facade</p>
<p><strong>外观模式</strong>是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以让自己的代码独立于复杂子系统。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>外观可能成为与程序中所有类都耦合的上帝对象。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p><strong>外观模式</strong>为现有对象定义了一个新接口， <strong>适配器模式</strong>则会试图运用已有的接口。 <strong>适配器</strong>通常只封装一个对象， <strong>外观</strong>通常会作用于整个对象子系统上。</p>
</li>
<li><p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用<strong>抽象工厂模式</strong>来代替<strong>外观</strong>。</p>
</li>
<li><p><strong>享元模式</strong>展示了如何生成大量的小型对象， <strong>外观</strong>则展示了如何用一个对象来代表整个子系统。</p>
</li>
<li><p><strong>外观</strong>和<strong>中介者模式</strong>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。</p>
</li>
<li><p><strong>外观</strong>为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</p>
<ul>
<li><strong>中介者</strong>将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li>
</ul>
</li>
<li><p><strong>外观类</strong>通常可以转换为<strong>单例模式类</strong>， 因为在大部分情况下一个外观对象就足够了。</p>
</li>
<li><p><strong>外观</strong>与<strong>代理模式</strong>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p>
</li>
</ul>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p><strong>亦称</strong>： 缓存、 Cache、 Flyweight</p>
<p><strong>享元模式</strong>是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>如果程序中有很多相似对象， 那么你将可以节省大量内存。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。</li>
<li>代码会变得更加复杂。 团队中的新成员总是会问：  “为什么要像这样拆分一个实体的状态？”。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p>你可以使用享元模式实现组合模式树的共享叶节点以节省内存。</p>
</li>
<li><p>享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。</p>
</li>
<li><p>如果你能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同。</p>
<ul>
<li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。 享元对象是不可变的。</li>
</ul>
</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>亦称</strong>： Proxy</p>
<p><strong>代理模式</strong>是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以在客户端毫无察觉的情况下控制服务对象。</li>
<li>如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。</li>
<li>即使服务对象还未准备好或不存在， 代理也可以正常工作。</li>
<li>开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>代码可能会变得复杂， 因为需要新建许多类。</li>
<li>服务响应可能会延迟。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>适配器模式</strong>能为被封装对象提供不同的接口， <strong>代理模式</strong>能为对象提供相同的接口， <strong>装饰模式</strong>则能为对象提供加强的接口。</li>
<li><strong>外观模式</strong>与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 <strong>代理</strong>与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与<strong>外观</strong>不同。</li>
<li><strong>装饰</strong>和<strong>代理</strong>有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于<strong>代理</strong>通常自行管理其服务对象的生命周期， 而<strong>装饰</strong>的生成则总是由客户端进行控制。</li>
</ul>
<h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><p>这类模式负责对象间的高效沟通和职责委派。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p><strong>亦称</strong>： 职责链模式、 命令链、 CoR、 Chain of Command、 Chain of Responsibility</p>
<p><strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以控制请求处理的顺序。</li>
<li>单一职责原则。你可对发起操作和执行操作的类进行解耦。</li>
<li>开闭原则。你可以在不更改现有代码的情况下在程序中新增处理者。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>部分请求可能未被处理。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p><strong>责任链模式</strong>、<strong>命令模式</strong>、<strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li><strong>责任链</strong>按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li><strong>命令</strong>在发送者和请求者之间建立单向连接。</li>
<li><strong>中介者</strong>清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li><strong>观察者</strong>允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><p><strong>责任链</strong>通常和<strong>组合模式</strong>结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li><p><strong>责任链</strong>的管理者可使用<strong>命令模式</strong>实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。</p>
</li>
<li><p><strong>责任链</strong>和<strong>装饰模式</strong>的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p>
</li>
</ul>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p><strong>亦称</strong>： 动作、 事务、 Action、 Transaction、 Command</p>
<p><strong>命令模式</strong>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>单一职责原则。 你可以解耦触发和执行操作的类。</li>
<li>开闭原则。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。</li>
<li>你可以实现撤销和恢复功能。</li>
<li>你可以实现操作的延迟执行。</li>
<li>你可以将一组简单命令组合成一个复杂命令。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p><strong>责任链模式</strong>、<strong>命令模式</strong>、<strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：</p>
</li>
<li><p><strong>责任链</strong>按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</p>
</li>
<li><p><strong>命令</strong>在发送者和请求者之间建立单向连接。</p>
<ul>
<li><strong>中介</strong>者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
</ul>
</li>
<li><p><strong>观察者</strong>允许接收者动态地订阅或取消接收请求。</p>
</li>
<li><p><strong>责任链</strong>的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。</p>
</li>
<li><p>你可以同时使用<strong>命令</strong>和<strong>备忘录模式</strong>来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作，<strong>备忘录</strong>用来保存一条命令执行前该对象的状态。</p>
</li>
<li><p><strong>命令</strong>和<strong>策略模式</strong>看上去很像，因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。</p>
<ul>
<li><p>你可以使用<strong>命令</strong>来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。</p>
</li>
<li><p>另一方面， <strong>策略</strong>通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。</p>
</li>
</ul>
</li>
<li><p><strong>原型模式</strong>可用于保存<strong>命令</strong>的历史记录。</p>
</li>
<li><p>你可以将<strong>访问者模式</strong>视为<strong>命令模式</strong>的加强版本， 其对象可对不同类的多种对象执行操作。</p>
</li>
</ul>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><strong>亦称</strong>： Iterator</p>
<p><strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</li>
<li>开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。</li>
<li>你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。</li>
<li>相似的， 你可以暂停遍历并在需要时继续。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。</li>
<li>对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p>你可以使用<strong>迭代器模式</strong>来遍历<strong>组合模式</strong>树。</p>
</li>
<li><p>你可以同时使用<strong>工厂方法模式</strong>和<strong>迭代器</strong>来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p>
</li>
<li><p>你可以同时使用<strong>备忘录模式</strong>和<strong>迭代器</strong>来获取当前迭代器的状态， 并且在需要的时候进行回滚。</p>
</li>
<li><p>可以同时使用<strong>访问者模式</strong>和<strong>迭代器</strong>来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</p>
</li>
</ul>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p><strong>亦称</strong>： 调解人、 控制器、 Intermediary、 Controller、 Mediator</p>
<p><strong>中介者模式</strong>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>单一职责原则。你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。</li>
<li>开闭原则。你无需修改实际组件就能增加新的中介者。</li>
<li>你可以减轻应用中多个组件间的耦合情况。</li>
<li>你可以更方便地复用各个组件。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>一段时间后，中介者可能会演化成为上帝对象。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>责任链模式</strong>、 <strong>命令模式</strong>、 <strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><strong>外观模式</strong>和<strong>中介者</strong>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。<ul>
<li><p>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</p>
</li>
<li><p>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</p>
</li>
</ul>
</li>
<li><strong>中介者</strong>和<strong>观察者</strong>之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。</li>
</ul>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p><strong>亦称</strong>： 快照、 Snapshot、 Memento</p>
<p><strong>备忘录模式</strong>是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以在不破坏对象封装情况的前提下创建对象状态快照。</li>
<li>你可以通过让负责人维护原发器状态历史记录来简化原发器代码。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果客户端过于频繁地创建备忘录， 程序将消耗大量内存。</li>
<li>负责人必须完整跟踪原发器的生命周期， 这样才能销毁弃用的备忘录。</li>
<li>绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p>你可以同时使用<strong>命令模式</strong>和<strong>备忘录模式</strong>来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， <strong>备忘录</strong>用来保存一条命令执行前该对象的状态。</p>
</li>
<li><p>你可以同时使用<strong>备忘录</strong>和<strong>迭代器模式</strong>来获取当前迭代器的状态， 并且在需要的时候进行回滚。</p>
</li>
<li><p>有时候<strong>原型模式</strong>可以作为<strong>备忘录</strong>的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</p>
</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><strong>亦称</strong>： 事件订阅者、 监听者、 Event-Subscriber、 Listener、 Observer</p>
<p><strong>观察者模式</strong>是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><em>开闭原则</em>。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。</li>
<li>你可以在运行时建立对象之间的联系。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>订阅者的通知顺序是随机的。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p><strong>责任链模式</strong>、<strong>命令模式</strong>、<strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li><em>责任链</em>按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li><em>命令</em>在发送者和请求者之间建立单向连接。</li>
<li><em>中介者</em>清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li><em>观察者</em>允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><p><strong>中介者</strong>和<strong>观察者</strong>之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。</p>
<p><strong>中介者</strong>的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 <em>观察者</em>的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。</p>
<p>有一种流行的<strong>中介者模式</strong>实现方式依赖于<strong>观察者</strong>。 对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当<em>中介者</em>以这种方式实现时， 它可能看上去与<em>观察者</em>非常相似。</p>
<p>当你感到疑惑时， 记住可以采用其他方式来实现<strong>中介者</strong>。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和<em>观察者</em>并不相同， 但这仍是一种<strong>中介者模式</strong>。</p>
<p>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的<strong>观察者</strong>。</p>
</li>
</ul>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p><strong>亦称</strong>： State</p>
<p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>单一职责原则。 将与特定状态相关的代码放在单独的类中。</li>
<li>开闭原则。 无需修改已有状态类和上下文就能引入新状态。</li>
<li>通过消除臃肿的状态机条件语句简化上下文代码。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>桥接模式</strong>、 <strong>状态模式</strong>和<strong>策略模式</strong>（在某种程度上包括<strong>适配器模式</strong>） 模式的接口非常相似。 实际上， 它们都基于<strong>组合模式</strong>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li><strong>状态</strong>可被视为<strong>策略</strong>的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 <em>策略</em>使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但<em>状态</em>模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><strong>亦称</strong>： Strategy</p>
<p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可以在运行时切换对象内的算法。</li>
<li>你可以将算法的实现和使用算法的代码隔离开来。</li>
<li>你可以使用组合来代替继承。</li>
<li>开闭原则。你无需对上下文进行修改就能够引入新的策略。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。</li>
<li>客户端必须知晓策略间的不同——它需要选择合适的策略。</li>
<li>许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样， 你使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>桥接模式</strong>、<strong>状态模式</strong>和<strong>策略模式</strong>（在某种程度上包括<strong>适配器模式</strong>） 模式的接口非常相似。 实际上， 它们都基于<strong>组合模式</strong>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li><strong>命令模式</strong>和<strong>策略</strong>看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。<ul>
<li>你可以使用<strong>命令</strong>来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。</li>
<li>另一方面， <strong>策略</strong>通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。</li>
</ul>
</li>
<li><strong>装饰模式</strong>可让你更改对象的外表，<strong>策略</strong>则让你能够改变其本质。</li>
<li><strong>模板方法模式</strong>基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。<strong>策略</strong>基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 <strong>模板方法</strong>在类层次上运作， 因此它是静态的。 <strong>策略</strong>在对象层次上运作， 因此允许在运行时切换行为。</li>
<li><strong>状态</strong>可被视为<strong>策略</strong>的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 <strong>策略</strong>使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但<strong>状态</strong>模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</li>
</ul>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p><strong>亦称</strong>： Template Method</p>
<p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。</li>
<li>你可将重复代码提取到一个超类中。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>部分客户端可能会受到算法框架的限制。</li>
<li>通过子类抑制默认步骤实现可能会导致违反_里氏替换原则_。</li>
<li>模板方法中的步骤越多，其维护工作就可能会越困难。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><strong>工厂方法模式</strong>是<strong>模板方法模式</strong>的一种特殊形式。 同时， <strong>工厂方法</strong>可以作为一个大型<em>模板方法</em>中的一个步骤。</li>
<li><strong>模板方法</strong>基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。<strong>策略模式</strong>基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 <strong>模板方法</strong>在类层次上运作， 因此它是静态的。 <em>策略</em>在对象层次上运作， 因此允许在运行时切换行为。</li>
</ul>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p><strong>亦称</strong>： Visitor</p>
<p><strong>访问者模式</strong>是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>开闭原则。 你可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。</li>
<li>单一职责原则。 可将同一行为的不同版本移到同一个类中。</li>
<li>访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者。</li>
<li>在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<ul>
<li><p>你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。</p>
</li>
<li><p>你可以使用访问者对整个组合模式树执行操作。</p>
</li>
<li><p>可以同时使用访问者和迭代器模式来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</p>
</li>
</ul>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p><strong>亦称</strong>： Interpreter</p>
<p><strong>解释器模式</strong>实现了一个表达式接口，该接口解释一个特定的上下文。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>可扩展性比较好，灵活。</li>
<li>增加了新的解释表达式的方式。 </li>
<li>易于实现简单文法。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>可利用场景比较少。 </li>
<li>对于复杂的文法比较难维护。 </li>
<li>解释器模式会引起类膨胀。</li>
<li>解释器模式采用递归调用方法。</li>
</ul>
<p><strong>与其他模式的关系</strong></p>
<p>- </p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%9F%BA%E7%A1%80/">
                                    <span class="chip bg-color">基础</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="数据结构与算法的学习">
                        
                        <span class="card-title">数据结构与算法的学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            数据结构与算法[TOC]
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-07-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            linPeng
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%9F%BA%E7%A1%80/">
                        <span class="chip bg-color">基础</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/07/11/linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="安装linux系统">
                        
                        <span class="card-title">安装linux系统</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            linux简介linux是一套免费使用和自由传播的类UNIX操作系统,常见的发行版本有RedHat,Centos等.由于红帽被IBM收购,可以多尝试其他的linux发行版,如:华为的openEuler.
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-07-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/linux/" class="post-category">
                                    linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%9F%BA%E7%A1%80/">
                        <span class="chip bg-color">基础</span>
                    </a>
                    
                    <a href="/tags/%E7%8E%AF%E5%A2%83/">
                        <span class="chip bg-color">环境</span>
                    </a>
                    
                    <a href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">
                        <span class="chip bg-color">自动化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2700388203"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">linPeng</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/linPng" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>















    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
